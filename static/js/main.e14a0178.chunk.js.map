{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["TileData","id","emoji","mask","this","matched","isOpen","getRandomNumber","min","max","Math","floor","random","Tile","props","tile","onClick","e","className","Board","console","log","tiles","map","index","key","x","React","Component","App","state","name","click1TileId","click2TileId","clickCounter","matchCounter","timerHandle","undefined","maxTileNumber","length","singleSetLength","baseEmojis","split","emojis1","emojis2","randomStart","slice","randomNumberToPop","emojiToPlace","splice","push","setState","tileId","clickEventId","updatedTiles","document","getElementById","innerHTML","window","clearInterval","elmentId","el","setInterval","innerText","parseInt","event","target","warn","initTimer","matchTiles","addEventListener","buildTileData","removeEventListener","handleClick","Boolean","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.e14a0178.chunk.js","sourcesContent":["import React from 'react';\n// import logo from './logo.svg';\nimport './App.css';\n// import '../public/w3.css';\n\n// let tileCount = 0;\n\nclass TileData {\n    id;\n    matched;\n    emoji;\n    mask;\n\n    constructor(id, emoji, mask) {\n        this.id = id;\n        this.matched = false;\n        this.emoji = emoji;\n        this.mask = mask;\n        this.isOpen = false;\n    }\n}\n\n/**\n * Returns a random number in given range\n * @param {Number} min - Minimum number\n * @param {Number} max - Maximum number\n */\nconst getRandomNumber = (min, max) => Math.floor((Math.random() * max) + min);\n\nfunction Tile(props) {\n    // console.log(\"rendering tile\");\n\n    // console.log(props);\n    return (\n        <button id={props.tile.id} onClick={(e) => props.onClick(e)} className={props.tile.matched ? \"item\" : \"item\"}>{(props.tile.isOpen) ? props.tile.emoji : props.tile.mask}</button>\n    );\n}\n\nclass Board extends React.Component {\n\n    constructor(props) {\n        console.log(\"rendering body\");\n        super(props);\n    }\n\n    render() {\n\n        return (\n            <div className={\"container\"}>\n                {this.props.tiles.map((tile, index) => { return <Tile key={index} tile={tile} onClick={(x) => this.props.onClick(x)}></Tile> })}\n            </div>\n        );\n\n    };\n\n\n}\n\nclass App extends React.Component {\n\n    constructor(props) {\n        super(props);\n        this.state = {\n            name: \"taptap by Dilli\",\n            click1TileId: -1,\n            click2TileId: -1,\n            clickCounter: 0,\n            matchCounter: 0,\n            tiles: [],\n            timerHandle: undefined,\n            maxTileNumber: 25,\n        }\n    }\n\n    // calculateTileCount() {\n    //   console.log(\"calulating tile count\");\n    //   const width = window.innerWidth;\n    //   const height = window.innerHeight;\n\n    //   let rows = 5;\n\n    //   if (height > 900) {\n    //     console.log(height, \"desktop h\");\n    //     rows = 12;\n    //   }\n    //   else if (height > 801 && height <= 899) {\n    //     console.log(height, \"tablets h\");\n    //     rows = 10;\n    //   }\n    //   else if (height > 641 && height <= 800) {\n    //     console.log(height, \"ipad h\");\n    //     rows = 8;\n    //   }\n    //   else if (height > 481 && height <= 640) {\n    //     console.log(height, \"phone h\");\n    //     rows = 8;\n    //   }\n    //   else if (height > 320 && height <= 480) {\n    //     console.log(height, \"phone h\");\n    //     rows = 6;\n    //   }\n    //   else {\n    //     console.log(height, \"unknown phone h\")\n    //     rows = 5;\n    //   }\n\n\n    //   if (width > 1025) {\n    //     console.log(width, \"desktop w\");\n    //     tileCount = 15 * rows;\n    //   }\n    //   else if (width > 801 && width <= 1024) {\n    //     console.log(width, \"tablets w\");\n    //     tileCount = 12 * rows;\n    //   }\n    //   else if (width > 641 && width <= 800) {\n    //     console.log(width, \"ipad w\");\n    //     tileCount = 10 * rows;\n    //   }\n    //   else if (width > 320 && width <= 640) {\n    //     console.log(width, \"phone w\");\n    //     tileCount = 5 * rows;\n    //   }\n    //   else {\n    //     console.log(width, \"unknown phone w\")\n    //     tileCount = 5 * rows;\n    //   }\n    //   console.log(\"new tile count\", tileCount);\n    //   return tileCount % 2 === 0 ? tileCount : tileCount + 1;\n    // }\n\n    /**\n     * builds tile data and adds to state\n     */\n    buildTileData() {\n\n        let length = this.state.maxTileNumber;\n        let singleSetLength = Math.floor(length / 2);\n\n        // debugger;\n        const tiles = [];\n        const mask = \"ğŸ’\";\n        const clown = \"ğŸ¤¡\";\n        const baseEmojis = `\n    ğŸ”¥,ğŸ™ˆ,â¤ï¸,ğŸ¶,ğŸ¦Š,ğŸ¦,ğŸ’£,ğŸˆ,ğŸ˜œ,â˜ï¸,ğŸ—¿,ğŸ‰,ğŸ‹,ğŸ,ğŸ•,ğŸŸ,ğŸ‚,ğŸ¬,\n    ğŸ¦‹,ğŸŒ·,ğŸ,ğŸŒ,ğŸŒˆ,ğŸï¸,âš½,ğŸ­,ğŸ˜,ğŸ¤ ,ğŸ‘»,ğŸ‘¸,ğŸ§™,ğŸ§,ğŸ¦„,ğŸ«,ğŸ­,ğŸ’,ğŸŒŠ,\n    ğŸ§™â€â™€ï¸,ğŸ§šâ€â™€ï¸,ğŸ§â€â™€ï¸,ğŸ˜,ğŸ°,ğŸ»,ğŸ¨,ğŸ§,ğŸ•Šï¸,ğŸ¢,ğŸ¦ˆ,ğŸ,ğŸ,ğŸŒŠ,â˜ƒï¸,ğŸŒœ,ğŸ€,ğŸ¦€,ğŸŒ»,\n    ğŸ’Œ,âŒ›,â›±ï¸,ğŸ€,ğŸ,ğŸ”‹,ğŸ”‘,ğŸ”’,ğŸ”«,ğŸ›’,ğŸ§›â€â™€ï¸,ğŸ‘©â€ğŸ³,ğŸ¤—,ğŸ‘½\n    `.split(\",\");\n\n        /**\n         * \n         * ? the following items are not working in windows machine\n         * * ğŸ¦š,ğŸ¦©,ğŸ¥­, ğŸ¦¢,ğŸ¦œ,ğŸ§­, ğŸ§¨,ğŸª,ğŸ§¸,ğŸ§², ğŸ¥º\n         */\n        let emojis1 = [];\n        let emojis2 = [];\n        let randomStart = Math.floor(Math.random() * baseEmojis.length);\n        emojis1 = ((baseEmojis.length - randomStart) >= singleSetLength) ? baseEmojis.slice(randomStart) : baseEmojis.slice(randomStart - singleSetLength);\n        emojis1 = emojis1.slice(0, singleSetLength);\n        emojis2 = emojis1.slice(); // take a copy\n\n        for (var index = 0; index < length; index++) {\n            let randomNumberToPop = emojis1.length !== 0 ? getRandomNumber(0, emojis1.length) : getRandomNumber(0, emojis2.length);\n            let emojiToPlace = emojis1.length !== 0 ? emojis1[randomNumberToPop] : emojis2[randomNumberToPop];\n            // since we can't pop element at index, we are splicing element at index\n            emojis1.length !== 0 ? emojis1.splice(randomNumberToPop, 1) : emojis2.splice(randomNumberToPop, 1);\n            tiles.push(new TileData(index, emojiToPlace === undefined ? clown : emojiToPlace, mask));\n        }\n\n        // console.log(\"\");\n        this.setState({ tiles: tiles }, () => console.log(\"tiles are built by builder\"));\n    }\n\n    /**\n     * Matches current tile and previous open tile\n     * @param {*} tileId - current open time id\n     * @param {*} clickEventId - click counter till now\n     */\n    matchTiles(tileId, clickEventId) {\n        console.log(\"made copy of tiles\");\n        var updatedTiles = this.state.tiles.slice();\n        updatedTiles[tileId].isOpen = true;\n\n\n        console.log(\"matchig tiles\", this.state.click1TileId, this.state.click2TileId);\n        if (this.state.click1TileId !== -1 && this.state.click2TileId !== -1) {\n            if (this.state.tiles[this.state.click1TileId].emoji === this.state.tiles[this.state.click2TileId].emoji) {\n                updatedTiles[this.state.click1TileId].matched = true;\n                updatedTiles[this.state.click2TileId].matched = true;\n                console.log(\"tile matched\");\n                this.setState({ click1TileId: -1, click2TileId: -1, matchCounter: this.state.matchCounter + 1 }, () => {\n                    console.log(\"checking match\", this.state.matchCounter, Math.floor(this.state.maxTileNumber / 2), this.state.timerHandle);\n                    if (this.state.matchCounter === Math.floor(this.state.maxTileNumber / 2)) {\n                        console.log(\"match stopped;\", this.state.matchCounter, Math.floor(this.state.maxTileNumber / 2), this.state.timerHandle);\n                        console.log(\"clearning interval\", this.state.timerHandle);\n                        document.getElementById(\"result\").innerHTML = `<span>ğŸ‰ğŸ‰ğŸ‰CongratulationsğŸ‰ğŸ‰ğŸ‰<br>ğŸ‘You've completedğŸ‘</span>\n            <br><button id=\"btnReplay\" onclick=\"window.location.reload()\">Replay</button>`;\n                        window.clearInterval(this.state.timerHandle);\n                    }\n                });\n            }\n            else {\n                console.log(\"tile not matched\");\n                updatedTiles[this.state.click1TileId].matched = false;\n                updatedTiles[this.state.click2TileId].matched = false;\n\n\n                // this.setState({ click1TileId: -1}, ()=> console.log(\"click1 tile closed\"));\n                if (this.state.clickCounter % 2 === 1) {\n                    this.setState({ click2TileId: -1 }, () => console.log(\"click1 tile closed\"));\n                    updatedTiles[this.state.click2TileId].isOpen = false;\n\n                } else {\n                    updatedTiles[this.state.click1TileId].isOpen = false;\n                    this.setState({ click1TileId: -1 }, () => console.log(\"click1 tile closed\"));\n                }\n            }\n        } else {\n            console.log(\"tile match cancelled\");\n        }\n        this.setState({ tiles: updatedTiles }, () => {\n            console.log(\"tiles updated for click event id\", clickEventId);\n            console.log(\"##################################################\");\n        });\n    }\n\n    /**\n     * \n     * @param {HTMLID} elmentId - HTML Id of the element to be used as counter/timer\n     */\n    initTimer(elmentId) {\n        const el = document.getElementById(elmentId);\n        // console.log(\"int \", el);\n        let timerHandle = window.setInterval(function () {\n            el.innerText = el.innerText === \"\" ? 0 : parseInt(el.innerText) + 1;\n            // console.log(\"timer inc\", el.innerText);\n        }, 1000);\n        this.setState({ timerHandle: timerHandle }, () => console.log(\"timer handle is set\", timerHandle, this.state.timerHandle));\n    }\n\n    handleClick(event) {\n        const tileId = event.target.id;\n\n        if (this.state.tiles[tileId].isOpen) {\n            console.warn(\"click on invalid tile\");\n            return;\n        }\n\n        this.setState({ clickCounter: this.state.clickCounter + 1 }, () => {\n            if (this.state.clickCounter === 1) {\n                this.initTimer(\"timer\");\n                console.log(\"timer started\");\n            }\n            console.log(\"******************************************************\");\n            console.log(\"for click id\", this.state.clickCounter, this.state.clickCounter % 2, this.state.clickCounter % 2 === 0);\n\n            if (this.state.clickCounter % 2 === 1) {\n                console.log(\"seting click1 tile id\");\n                this.setState({ click1TileId: tileId }, () => {\n                    console.log(\"click1tileid set\");\n                    this.matchTiles(tileId, this.state.clickCounter)\n                });\n            } else {\n                console.log(\"seting click2 tile id\");\n                this.setState({ click2TileId: tileId }, () => {\n                    console.log(\"click2tileid set\");\n                    this.matchTiles(tileId, this.state.clickCounter)\n                });\n            }\n\n        });\n\n    }\n\n    componentDidMount() {\n        window.addEventListener('resize', () => {\n            console.log(\"window resize\");\n            this.buildTileData();\n        });\n        window.addEventListener('load', () => {\n            console.log(\"window resize\");\n            this.buildTileData();\n        });\n\n    }\n    componentWillUnmount() {\n        window.removeEventListener('resize', () => {\n            console.log(\"window resize\");\n            this.buildTileData();\n        });\n        window.addEventListener('load', () => {\n            console.log(\"window resize\");\n            this.buildTileData();\n        });\n    }\n\n    render() {\n        return (\n            <div>\n                <header id=\"header\">Find matches</header>\n                <Board className={\"center-me\"} tiles={this.state.tiles} onClick={(x) => this.handleClick(x)} ></Board>\n                <div id=\"info-container\">\n                    <p id=\"clicks-container\"> Clicks: <span id=\"clicks\">{this.state.clickCounter}</span></p>\n                    <p id=\"matches-container\"> Matches: <span id=\"matches\">{this.state.matchCounter}</span></p>\n                    <p id=\"timer-container\">Timer: <span id=\"timer\">0</span></p>\n                    <p id=\"result-container\"><span id=\"result\"></span></p>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}